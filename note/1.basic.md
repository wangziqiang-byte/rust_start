# 变量
- 所有对于变量的初始化操作都理解为绑定而非赋值，因为默认情况下定义的变量是不可变的。
- 对于不用而又定义了的变量可以在变量前加`_`，否则会有warning。
    ```rust
    fn main {
        let a = 4;
        let _b = 6;
    }
    ```
    > warning 如下
    ```
    warning: unused variable: `a`
    --> src/main.rs:2:9
    |
    2 |     let a = 4;
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`
    |
    = note: `#[warn(unused_variables)]` on by default

    warning: `demo` (bin "demo") generated 1 warning
    ```
- 变量shadowing：
    ```rust
    fn main() {
        let a = 5;
        let a = 6;
        println!("{}", a)
    }

    ```
    > cargo run 如下
    ```
    warning: unused variable: `a`
    --> src/main.rs:2:9
    |
    2 |     let a = 5;
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`
    |
    = note: `#[warn(unused_variables)]` on by default

    warning: `demo` (bin "demo") generated 1 warning
        Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.97s
        Running `target/debug/demo`
    6
    ```
# 数值类型
- 默认整数i32，默认浮点类型是 f64，usize与isize是机器多少位它就多少位。

    ![alt text](img/var_size.png) 
    ![alt text](img/var_size1.png)
    - 整数溢出处理：当溢出时在debug模式下编译运行的rust会进行检查，如果溢出则panic，但是在release下则不会报错了。溢出大的处理就是采取循环进位，比如在 u8 的情况下，256 变成 0，257 变成 1。
    - 显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
        - 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理
        - 如果使用 `checked_*` 方法时发生溢出，则返回 None 值
        - 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
        - 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值
    ```rust
    fn main() {
        let a: u8 = 255;
        println!("a= {}", a);
        // panicked: attempt to add with overflow
        // println!("a= {}", a + 2);
        let a: u8 = 255;
        println!("a= {:#?}", a.wrapping_add(2));
        println!("a= {:#?}", a.checked_add(2));
        println!("a= {:#?}", a.overflowing_add(2));
        let (num, is_overflow) = a.overflowing_add(2);
        println!("num= {:#?}, is_overflow= {}", num, is_overflow);
        println!("a= {:#?}", a.saturating_add(2));
    }
    ```
    > output 
    ```
    a= 255
    a= 1
    a= None
    a= (
        1,
        true,
    )
    num= 1, is_overflow= true
    a= 255
    ```
- 浮点数的比较，abs取决于精度需求是多少。
    ```rust 
    fn main() {
        let a = 0.1;
        let b = 0.2;
        let c: f64 = 0.3;
        let is_eq = a + b == c;
        println!("is_eq = {}", is_eq);
        // 若a或b或c不指定为f64则panic,因为assert不能分辨计算后的类型
        let is_eq = (c - a - b).abs() < 0.0001;
        println!("is_eq = {}", is_eq);
    }
    ```
    > output 
    ```
    is_eq = false
    is_eq = true
    ```

# 序列

```rust
fn main() {
    for i in 1..4 {
        print!("{}", i);
    }
    println!("");
    for i in 1..=4 {
        print!("{}", i);
    }
}

```

> output 
```
123
1234
```

# 函数
```rust
关键字  方法名 (形参名: 形参类型) -> 返回值类型 {
    ...
}
fn add(i: i32, j: i32) -> i32 {
   i + j
 }
```

# 所有权
- 栈和堆的区别
> 在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，**处理器在栈上分配数据会比在堆上分配数据更加高效。**


## 所有权原则
>> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者。
>> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
>> 3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

## 例子
- 当所有权转移时，可变性也可以随之改变。
```rust
fn main() {
    let s = String::from("hello, ");
    let mut s1 = s;
    s1.push_str("world")
}
```

-- 引用：s1,s2分别借用了t的两个值但是并没有获取所有权。
```rust

fn main() {
   let t = (String::from("hello"), String::from("world"));
   // 也可以 let (s1, s2) = &t;
   let (s1, s2) = (&t.0, &t.1);
   println!("{:?}, {:?}, {:?}", s1, s2, t); // -> "hello", "world", ("hello", "world")
}
```

- 变量失效demo
```rust
fn main() {
    let mut s = String::from("hello");
 
     let r1 = &s;
     let r2 = &s;
     println!("{} and {}", r1, r2);
     // 新编译器中，r1,r2作用域在这里结束
 
     let r3 = &mut s;
     println!("{}", r3);
 } // 老编译器中，r1、r2、r3作用域在这里结束
   // 新编译器中，r3作用域在这里结束
```

